/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package sampleapp;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import cars2.mainSystem;
import cars2.Vehicle;
import cars2.SUV;
import cars2.Truck;
import cars2.Van;
import cars2.Fault;
import cars2.Mechanical;
import cars2.Electrical;
import cars2.Software;
import cars2.Owner;
import cars2.SubSystem;
import cars2.TimeWindow;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map.Entry;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

@Command(name = "App", mixinStandardHelpOptions = true, version = "App 1.0")
public class App implements Runnable{

    //@Option(names = { "-n", "--name" }, description = "Your name")
    @Option(names = {"-a", "--archives"}, defaultValue = "VehicleArchive", 
    description = "Your archive (example: ${DEFAULT-VALUE}, FaultArchive, OwnerArchive, SubSystemArchive, and subtypes.)", 
    interactive = true)
    private String archives;

    @Option(names = {"-ft", "--faultType"}, defaultValue = "Mechanical", description = "Enter a fault type", interactive = true)
    private String faultType;

    @Option(names = {"-v", "--vehicleID"}, defaultValue = "NISQAUXSQDPOET", description = "Enter a vehicle ID", interactive = true)
    private String vehicleID;

    @Option(names = {"-fid", "--faultID"}, defaultValue = "SLYCLEUNCLDUZV", description = "Enter a fault ID", interactive = true)
    private String faultID;

    @Option(names = {"-ts", "timeStarted"}, defaultValue = "1993-03-01T00:00:00", description = "Enter a start time", interactive = true)
    private String timeStarted;

    @Option(names = {"-tc", "timeCleared"}, defaultValue = "1993-09-02T14:32:27", description = "Enter a clearance time", interactive = true)
    private String timeCleared;

    @Option(names = {"-nh", "nameOfHashmap"}, defaultValue = "VehicleCollection", arity = "0..1", 
    description = "Name of hashmap that data will be collected from", interactive = true)
    private String[] nameOfHashmap;

    @Option(names = {"-d", "dataName"}, defaultValue = "yearofmanufacture", arity = "0..1", 
    description = "Name of data that will be made into a list (e.g. ${DEFAULT-VALUE})", 
    interactive = true)
    private String[] dataName;

    @Option(names = {"-ns", "numOfSamples"}, defaultValue = "8", arity = "0..1", description = "How many samples will be taken for this list", interactive = true)
    private int[] numOfSamples;

    @Option(names = {"-s", "systematic"}, defaultValue = "false", arity = "0..1", description = "Type true for systematic, false for random", interactive = true)
    private boolean[] systematic;

    public static void main(String[] args) 
    {
        // Library l = new Library();
        // l.someLibraryMethod();
        // White box testing to make sure that the app can call methods from the library. 
        CommandLine cl = new CommandLine(new App());
        cl.execute(args);
    }

    @Override 
    public void run()
    {
        try {
             mainSystem m = new mainSystem();
             TimeWindow twTest = new TimeWindow(timeStarted, timeCleared);
             if (archives.equals("VehicleArchive"))
             {
                displayAllVehicles(m);
             }
             else if (archives.equals("FaultArchive"))
             {
                displayAllFaults(m);
             }
             else if (archives.equals("OwnerArchive"))
             {
                displayAllOwners(m);
             }
             else if (archives.equals("SubSystemArchive"))
             {
                displayAllSubSystems(m);
             }
             else if (archives.equals("SUVArchive"))
             {
                displayAllSUVs(m);
             }
             else if (archives.equals("TruckArchive"))
             {
                displayAllTrucks(m);
             }
             else if (archives.equals("VanArchive"))
             {
                displayAllVans(m);
             }
             else if (archives.equals("MechArchive"))
             {
                displayAllMechanicals(m);
             }
             else if (archives.equals("ElectArchive"))
             {
                displayAllElectricals(m);
             }
             else if (archives.equals("SoftArchive"))
             {
                displayAllSoftwares(m);
             }
             else if (archives.equals("Mostfaults"))
             {
                mostFaults(m);
             }
             else if (archives.equals("Vehicleswithactivefaults"))
             {
                vehiclesWithActiveFaults(m);
             }
             else if (archives.equals("Mostcommonfault"))
             {
                mostCommonFault(m);
             }
             else if (archives.equals("Rarestfault"))
             {
                rarestFault(m);
             }
             else if (archives.equals("Vehicleswithtypeoffault"))
             {
                vehiclesWithTypeOfFault(faultType, m);
             }
             else if (archives.equals("Faultdensity"))
             {
                faultDensity(twTest, m);
             }
             else if (archives.equals("Aroundfault"))
             {
                Vehicle vTest = m.getVehicleCollection().get(vehicleID);
                aroundFault(vTest, faultID, twTest, true, m);
             }
             else if (archives.equals("Getdatalist"))
             {
                returnDataList(findHashMap(m, nameOfHashmap[0]), dataName[0], numOfSamples[0], systematic[0], true, m);
             }
             else if (archives.equals("r"))
             {
                LinkedList<Double> x = returnDataList(findHashMap(m, nameOfHashmap[0]), dataName[0], numOfSamples[0], systematic[0], false, m);
                LinkedList<Double> y = returnDataList(findHashMap(m, nameOfHashmap[1]), dataName[1], numOfSamples[1], systematic[1], false, null);
                r(x, y, m); 
             }
             else if (archives.equals("Equation"))
             {
               LinkedList<Double> x = returnDataList(findHashMap(m, nameOfHashmap[0]), dataName[0], numOfSamples[0], systematic[0], false, m);
               LinkedList<Double> y = returnDataList(findHashMap(m, nameOfHashmap[1]), dataName[1], numOfSamples[1], systematic[1], false, null);
                equation(x, y, m);
             }
             else if (archives.equals("Skew"))
             {
                LinkedList<Double> data = returnDataList(findHashMap(m, nameOfHashmap[0]), dataName[0], numOfSamples[0], systematic[0], false, m);
                skew(data, m);
             }
             else
             {
                System.out.println("Use --help to see options.");
             }
        } catch (Exception e)
        {
            e.printStackTrace();
            System.exit(-1);
        }
    }

    public <E> HashMap<String, E> findHashMap(mainSystem m, String nameOfHashmap) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException
    {
        HashMap<String, E> dataGiver = new HashMap<String, E>();
                Method[] methods = m.getClass().getDeclaredMethods();
                for (Method met : methods)
                {
                    String currentMethodName = met.getName();
                    if (currentMethodName.contains(nameOfHashmap))
                    {
                        dataGiver = (HashMap<String, E>) met.invoke(m);
                    }
                }
        return dataGiver;
    }

    public void displayAllVehicles(mainSystem m)
    {
        HashMap<String, Vehicle> vehicleCollection = m.getVehicleCollection();
        for (Entry<String, Vehicle> entry: vehicleCollection.entrySet())
        {
            System.out.println(entry.getValue());
        }
    }

    public void displayAllFaults(mainSystem m)
    {
        HashMap<String, Fault> faultCollection = m.getFaultCollection();
        for (Entry<String, Fault> entry: faultCollection.entrySet())
        {
            System.out.println(entry.getValue());
        }
    }

    public void displayAllOwners(mainSystem m)
    {
        HashMap<String, Owner> ownerCollection = m.getOwnerCollection();
        for (Entry<String, Owner> entry: ownerCollection.entrySet())
        {
            System.out.println(entry.getValue());
        }
    }

    public void displayAllSubSystems(mainSystem m)
    {
        HashMap<String, SubSystem> subSystemCollection = m.getSubSystemCollection();
        for (Entry<String, SubSystem> entry: subSystemCollection.entrySet())
        {
            System.out.println(entry.getValue());
        }
    }

    public void displayAllSUVs(mainSystem m)
    {
        HashMap<String, SUV> SUVCollection = m.getSUVCollection();
        for (Entry<String, SUV> entry: SUVCollection.entrySet())
        {
            System.out.println(entry.getValue());
        }
    }

    public void displayAllTrucks(mainSystem m)
    {
        HashMap<String, Truck> truckCollection = m.getTruckCollection();
        for (Entry<String, Truck> entry: truckCollection.entrySet())
        {
            System.out.println(entry.getValue());
        }
    }

    public void displayAllVans(mainSystem m)
    {
        HashMap<String, Van> vanCollection = m.getVanCollection();
        for (Entry<String, Van> entry: vanCollection.entrySet())
        {
            System.out.println(entry.getValue());
        }
    }

    public void displayAllMechanicals(mainSystem m)
    {
        HashMap<String, Mechanical> mechCollection = m.getMechFaultCollection();
        for (Entry<String, Mechanical> entry: mechCollection.entrySet())
        {
            System.out.println(entry.getValue());
        }
    }

    public void displayAllElectricals(mainSystem m)
    {
        HashMap<String, Electrical> electCollection = m.getElectFaultCollection();
        for (Entry<String, Electrical> entry: electCollection.entrySet())
        {
            System.out.println(entry.getValue());
        }
    }

    public void displayAllSoftwares(mainSystem m)
    {
        HashMap<String, Software> softCollection = m.getSoftFaultCollection();
        for (Entry<String, Software> entry: softCollection.entrySet())
        {
            System.out.println(entry.getValue());
        }
    }

    public void mostFaults(mainSystem m)
    {
       Vehicle mostFaults = m.mostFaults();
       if (mostFaults != null)
       {
            System.out.println(mostFaults); 
       }
       else
       {
            System.err.println("No vehicle found with most faults.");
       }
    } 

    public void vehiclesWithActiveFaults(mainSystem m)
    {
        ArrayList<Vehicle> vehActiveFaults = m.vehiclesWithActiveFaults();
        if (vehActiveFaults.size() > 0)
        {
            for (int vehIndex = 0; vehIndex < vehActiveFaults.size(); vehIndex++)
            {
                System.out.println(vehActiveFaults.get(vehIndex));
            }
        } 
        else
        {
            System.err.println("No vehicles with active faults.");
        }
    }

    public void rarestFault(mainSystem m)
    {
        Fault rarestFault = m.rarestFault();
        if (rarestFault != null)
        {
            System.out.println(rarestFault);
        }
        else
        {
            System.err.println("No rarest fault found.");
        }
    }

    public void mostCommonFault(mainSystem m)
    {
        Fault mostCommonFault = m.mostCommonFault();
        if (mostCommonFault != null)
        {
            System.out.println(mostCommonFault);
        }
        else
        {
            System.err.println("No most common fault found.");
        }
    }

    public void vehiclesWithTypeOfFault(String faultType, mainSystem m)
    {
        ArrayList<Vehicle> vehTypeFault = m.vehiclesWithTypeOfFault(faultType);
        if (vehTypeFault.size() > 0)
        {
            for (int vehIndex = 0; vehIndex < vehTypeFault.size(); vehIndex++)
            {
                System.out.println(vehTypeFault.get(vehIndex));
            }
        } 
        else
        {
            System.err.println("No vehicles with this type of fault.");
        }
    }

    public void faultDensity(TimeWindow timeWindow, mainSystem m)
    {
        double faultDensity = m.faultDensity(timeWindow);
        String fd = Double.toString(faultDensity);
        System.out.println(fd);
    }

    public void aroundFault(Vehicle vehicle, String faultID, TimeWindow timeWindow, boolean after, mainSystem m)
    {
        ArrayList<Fault> aroundFault = m.aroundFault(vehicle, faultID, timeWindow, after);
        if (aroundFault == null)
        {
            System.err.println("Fault not in vehicle");
            return;
        }

        if (aroundFault.size() > 0)
        {
            for (int vehIndex = 0; vehIndex < aroundFault.size(); vehIndex++)
            {
                System.out.println(aroundFault.get(vehIndex));
            }
        } 
        else
        {
            if (after)
            {
                System.err.println("No faults were after this fault.");
            }
            else
            {
                System.err.println("No faults were before this fault.");
            }
        }
    }

    public void r(LinkedList<Double> x, LinkedList<Double> y, mainSystem m)
    {
        double r = m.aspectFaultCorrelation(x, y);
        System.out.println(r);
    }

    public void equation(LinkedList<Double> x, LinkedList<Double> y, mainSystem m)
    {
        String equation = m.regressionEquation(x, y);
        System.out.println(equation);
    }

    public void skew(LinkedList<Double> data, mainSystem m)
    {
        double skew = m.skew(data);
        System.out.println(skew);
    }

    public <E, T> LinkedList<T> returnDataList(HashMap<String, E> dataGiver, String dataName, int numOfSamples, boolean systematic, boolean print, mainSystem m) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException
    {
        LinkedList<T> dataList = m.createDataList(dataGiver, dataName, numOfSamples, systematic);
        if (print)
        {
            for (int dataIndex = 0; dataIndex < dataList.size(); dataIndex++)
            {
                System.out.println(dataList.get(dataIndex));
            }
        }
        return dataList;
    }
}